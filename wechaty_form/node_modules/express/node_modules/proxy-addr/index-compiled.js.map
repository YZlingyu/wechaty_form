{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr;\nmodule.exports.all = alladdrs;\nmodule.exports.compile = compile;\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded');\nvar ipaddr = require('ipaddr.js');\n\n/**\n * Variables.\n * @private\n */\n\nvar digitre = /^[0-9]+$/;\nvar isip = ipaddr.isValid;\nvar parseip = ipaddr.parse;\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar ipranges = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs(req, trust) {\n  // get addresses\n  var addrs = forwarded(req);\n\n  if (!trust) {\n    // Return all addresses\n    return addrs;\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust);\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n\n    addrs.length = i + 1;\n  }\n\n  return addrs;\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n\n  var trust = typeof val === 'string'\n    ? [val]\n    : val;\n\n  if (!Array.isArray(trust)) {\n    throw new TypeError('unsupported trust argument');\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n\n    if (!ipranges.hasOwnProperty(val)) {\n      continue;\n    }\n\n    // Splice in pre-defined range\n    val = ipranges[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n\n  return compileTrust(compileRangeSubnets(trust));\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i]);\n  }\n\n  return rangeSubnets;\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust(rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length;\n  return len === 0\n    ? trustNone\n    : len === 1\n    ? trustSingle(rangeSubnets[0])\n    : trustMulti(rangeSubnets);\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation(note) {\n  var pos = note.lastIndexOf('/');\n  var str = pos !== -1\n    ? note.substring(0, pos)\n    : note;\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str);\n  }\n\n  var ip = parseip(str);\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address();\n  }\n\n  var max = ip.kind() === 'ipv6'\n    ? 128\n    : 32;\n\n  var range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : null;\n\n  if (range === null) {\n    range = max;\n  } else if (digitre.test(range)) {\n    range = parseInt(range, 10);\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range);\n  } else {\n    range = null;\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n\n  return [ip, range];\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask(netmask) {\n  var ip = parseip(netmask);\n  var kind = ip.kind();\n\n  return kind === 'ipv4'\n    ? ip.prefixLengthFromSubnetMask()\n    : null;\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n\n  var addrs = alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n\n  return addr;\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone() {\n  return false;\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti(subnets) {\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n\n    var ip = parseip(addr);\n    var ipconv;\n    var kind = ip.kind();\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i];\n      var subnetip = subnet[0];\n      var subnetkind = subnetip.kind();\n      var subnetrange = subnet[1];\n      var trusted = ip;\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue;\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4'\n            ? ip.toIPv4Address()\n            : ip.toIPv4MappedAddress();\n        }\n\n        trusted = ipconv;\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n\n    var ip = parseip(addr);\n    var kind = ip.kind();\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false;\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4\n        ? ip.toIPv4Address()\n        : ip.toIPv4MappedAddress();\n    }\n\n    return ip.match(subnetip, subnetrange);\n  };\n}\n"]}