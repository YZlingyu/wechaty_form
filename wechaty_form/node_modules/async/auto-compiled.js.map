{"version":3,"sources":["auto.js"],"names":[],"mappings":"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","file":"auto-compiled.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = (0, _once2.default)(callback || _noop2.default);\n    var keys = (0, _keys2.default)(tasks);\n    var numTasks = keys.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = {};\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    (0, _baseForOwn2.default)(tasks, function (task, key) {\n        if (!(0, _isArray2.default)(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        (0, _arrayEach2.default)(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        (0, _arrayEach2.default)(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = (0, _onlyOnce2.default)((0, _rest2.default)(function (err, args) {\n            runningTasks--;\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            if (err) {\n                var safeResults = {};\n                (0, _baseForOwn2.default)(results, function (val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = args;\n                hasError = true;\n                listeners = [];\n\n                callback(err, safeResults);\n            } else {\n                results[key] = args;\n                taskComplete(key);\n            }\n        }));\n\n        runningTasks++;\n        var taskFn = task[task.length - 1];\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            (0, _arrayEach2.default)(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        (0, _baseForOwn2.default)(tasks, function (task, key) {\n            if ((0, _isArray2.default)(task) && (0, _baseIndexOf2.default)(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\nvar _arrayEach = require('lodash/_arrayEach');\n\nvar _arrayEach2 = _interopRequireDefault(_arrayEach);\n\nvar _baseForOwn = require('lodash/_baseForOwn');\n\nvar _baseForOwn2 = _interopRequireDefault(_baseForOwn);\n\nvar _baseIndexOf = require('lodash/_baseIndexOf');\n\nvar _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _keys = require('lodash/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _rest = require('./internal/rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _once = require('./internal/once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/**\n * Determines the best order for running the functions in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the functions pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * Functions also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the function itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */"]}