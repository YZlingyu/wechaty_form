{"version":3,"sources":["retry.js"],"names":[],"mappings":"AAAA;;AAEA,OAAO,cAAP,CAAsB,OAAtB,EAA+B,YAA/B,EAA6C;AACzC,WAAO;AADkC,CAA7C;AAGA,QAAQ,OAAR,GAAkB,KAAlB;;AAEA,IAAI,QAAQ,QAAQ,aAAR,CAAZ;;AAEA,IAAI,SAAS,uBAAuB,KAAvB,CAAb;;AAEA,IAAI,YAAY,QAAQ,iBAAR,CAAhB;;AAEA,IAAI,aAAa,uBAAuB,SAAvB,CAAjB;;AAEA,SAAS,sBAAT,CAAgC,GAAhC,EAAqC;AAAE,WAAO,OAAO,IAAI,UAAX,GAAwB,GAAxB,GAA8B,EAAE,SAAS,GAAX,EAArC;AAAwD;;AAE/F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFA,SAAS,KAAT,CAAe,IAAf,EAAqB,IAArB,EAA2B,QAA3B,EAAqC;AACjC,QAAI,gBAAgB,CAApB;AACA,QAAI,mBAAmB,CAAvB;;AAEA,QAAI,UAAU;AACV,eAAO,aADG;AAEV,sBAAc,CAAC,GAAG,WAAW,OAAf,EAAwB,gBAAxB;AAFJ,KAAd;;AAKA,aAAS,UAAT,CAAoB,GAApB,EAAyB,CAAzB,EAA4B;AACxB,YAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B;AACvB,gBAAI,KAAJ,GAAY,CAAC,EAAE,KAAH,IAAY,aAAxB;;AAEA,gBAAI,YAAJ,GAAmB,OAAO,EAAE,QAAT,KAAsB,UAAtB,GAAmC,EAAE,QAArC,GAAgD,CAAC,GAAG,WAAW,OAAf,EAAwB,CAAC,EAAE,QAAH,IAAe,gBAAvC,CAAnE;;AAEA,gBAAI,WAAJ,GAAkB,EAAE,WAApB;AACH,SAND,MAMO,IAAI,OAAO,CAAP,KAAa,QAAb,IAAyB,OAAO,CAAP,KAAa,QAA1C,EAAoD;AACvD,gBAAI,KAAJ,GAAY,CAAC,CAAD,IAAM,aAAlB;AACH,SAFM,MAEA;AACH,kBAAM,IAAI,KAAJ,CAAU,mCAAV,CAAN;AACH;AACJ;;AAED,QAAI,UAAU,MAAV,GAAmB,CAAnB,IAAwB,OAAO,IAAP,KAAgB,UAA5C,EAAwD;AACpD,mBAAW,QAAQ,OAAO,OAA1B;AACA,eAAO,IAAP;AACH,KAHD,MAGO;AACH,mBAAW,OAAX,EAAoB,IAApB;AACA,mBAAW,YAAY,OAAO,OAA9B;AACH;;AAED,QAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC5B,cAAM,IAAI,KAAJ,CAAU,mCAAV,CAAN;AACH;;AAED,QAAI,UAAU,CAAd;AACA,aAAS,YAAT,GAAwB;AACpB,aAAK,UAAU,GAAV,EAAe;AAChB,gBAAI,OAAO,YAAY,QAAQ,KAA3B,KAAqC,OAAO,QAAQ,WAAf,IAA8B,UAA9B,IAA4C,QAAQ,WAAR,CAAoB,GAApB,CAAjF,CAAJ,EAAgH;AAC5G,2BAAW,YAAX,EAAyB,QAAQ,YAAR,CAAqB,OAArB,CAAzB;AACH,aAFD,MAEO;AACH,yBAAS,KAAT,CAAe,IAAf,EAAqB,SAArB;AACH;AACJ,SAND;AAOH;;AAED;AACH;AACD,OAAO,OAAP,GAAiB,QAAQ,SAAR,CAAjB","file":"retry-compiled.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = retry;\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _constant = require('lodash/constant');\n\nvar _constant2 = _interopRequireDefault(_constant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {Function} task - A function which receives two arguments: (1) a\n * `callback(err, result)` which must be called when finished, passing `err`\n * (which can be `null`) and the `result` of the function's execution, and (2)\n * a `results` object, containing the results of the previously executed\n * functions (if nested inside another control flow). Invoked with\n * (callback, results).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // It can also be embedded within other control flow functions to retry\n * // individual methods that are not as reliable, like this:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retry(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: (0, _constant2.default)(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : (0, _constant2.default)(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || _noop2.default;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || _noop2.default;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var attempt = 1;\n    function retryAttempt() {\n        task(function (err) {\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\nmodule.exports = exports['default'];"]}