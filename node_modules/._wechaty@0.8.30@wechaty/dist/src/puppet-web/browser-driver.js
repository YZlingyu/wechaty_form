"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Wechaty - Wechat for Bot. Connecting ChatBots
 *
 * BrowserDriver
 *
 * Licenst: ISC
 * https://github.com/wechaty/wechaty
 *
 */
const selenium_webdriver_1 = require("selenium-webdriver");
const config_1 = require("../config");
class BrowserDriver {
    constructor(head) {
        this.head = head;
        config_1.log.verbose('PuppetWebBrowserDriver', 'constructor(%s)', head);
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetWebBrowserDriver', 'init() for head: %s', this.head);
            switch (this.head) {
                case 'phantomjs':
                    this.driver = yield this.getPhantomJsDriver();
                    break;
                case 'firefox':
                    this.driver = new selenium_webdriver_1.Builder()
                        .setAlertBehavior('ignore')
                        .forBrowser('firefox')
                        .build();
                    break;
                case 'chrome':
                    yield this.initChromeDriver();
                    break;
                default:
                    throw new Error('unsupported head: ' + this.head);
            }
            yield this.driver.manage()
                .timeouts()
                .setScriptTimeout(10000);
            return this;
        });
    }
    initChromeDriver() {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetWebBrowserDriver', 'initChromeDriver()');
            /**
             * http://stackoverflow.com/a/27733960/1123955
             * issue #56
             * only need under win32 with cygwin
             * and will cause strange error:
             *
             */
            /*
            const chrome  = require('selenium-webdriver/chrome')
            const path    = require('chromedriver').path
        
            const service = new chrome.ServiceBuilder(path).build()
            try {
              chrome.setDefaultService(service)
            } catch (e) { // fail safe
               // `The previously configured ChromeDriver service is still running.`
               // `You must shut it down before you may adjust its configuration.`
            }
           */
            const options = {
                args: [
                    '--homepage=about:blank',
                    '--no-sandbox',
                ],
            };
            if (config_1.Config.isDocker) {
                config_1.log.verbose('PuppetWebBrowserDriver', 'initChromeDriver() wechaty in docker confirmed(should not show this in CI)');
                options['binary'] = config_1.Config.CMD_CHROMIUM;
            }
            else {
                /**
                 * https://github.com/Chatie/wechaty/pull/416
                 * In some circumstances, ChromeDriver could not be found on the current PATH when not in Docker.
                 * The chromedriver package always adds directory of chrome driver binary to PATH.
                 * So we requires chromedriver here to avoid PATH issue.
                 */
                require('chromedriver');
            }
            const customChrome = selenium_webdriver_1.Capabilities.chrome()
                .set('chromeOptions', options);
            // TODO: chromedriver --silent
            if (!/^(verbose|silly)$/i.test(config_1.log.level())) {
                const prefs = new selenium_webdriver_1.logging.Preferences();
                prefs.setLevel(selenium_webdriver_1.logging.Type.BROWSER, selenium_webdriver_1.logging.Level.OFF);
                prefs.setLevel(selenium_webdriver_1.logging.Type.CLIENT, selenium_webdriver_1.logging.Level.OFF);
                prefs.setLevel(selenium_webdriver_1.logging.Type.DRIVER, selenium_webdriver_1.logging.Level.OFF);
                prefs.setLevel(selenium_webdriver_1.logging.Type.PERFORMANCE, selenium_webdriver_1.logging.Level.OFF);
                prefs.setLevel(selenium_webdriver_1.logging.Type.SERVER, selenium_webdriver_1.logging.Level.OFF);
                customChrome.setLoggingPrefs(prefs);
            }
            /**
             * XXX when will Builder().build() throw exception???
             */
            let retry = 0;
            let driverError = new Error('initChromeDriver() invalid driver error');
            let valid = false;
            do {
                if (retry > 0) {
                    config_1.log.warn('PuppetWebBrowserDriver', 'initChromeDriver() with retry: %d', retry);
                }
                try {
                    config_1.log.verbose('PuppetWebBrowserDriver', 'initChromeDriver() new Builder()');
                    this.driver = new selenium_webdriver_1.Builder()
                        .setAlertBehavior('ignore')
                        .forBrowser('chrome')
                        .withCapabilities(customChrome)
                        .build();
                    config_1.log.verbose('PuppetWebBrowserDriver', 'initChromeDriver() new Builder() done');
                    valid = yield this.valid(this.driver);
                    config_1.log.verbose('PuppetWebBrowserDriver', 'initChromeDriver() valid() done: %s', valid);
                    if (!valid) {
                        const e = new Error('initChromeDriver() got invalid driver');
                        config_1.log.warn('PuppetWebBrowserDriver', e.message);
                        driverError = e;
                    }
                }
                catch (e) {
                    if (/could not be found/.test(e.message)) {
                        // The ChromeDriver could not be found on the current PATH
                        config_1.log.error('PuppetWebBrowserDriver', 'initChromeDriver() Wechaty require `chromedriver` to be installed.(try to run: "npm install chromedriver" to fix this issue)');
                        throw e;
                    }
                    config_1.log.warn('PuppetWebBrowserDriver', 'initChromeDriver() exception: %s, retry: %d', e.message, retry);
                    driverError = e;
                }
            } while (!valid && retry++ < 3);
            if (!valid) {
                config_1.log.warn('PuppetWebBrowserDriver', 'initChromeDriver() not valid after retry: %d times: %s', retry, driverError.stack);
                throw driverError;
            }
            else {
                config_1.log.silly('PuppetWebBrowserDriver', 'initChromeDriver() success');
            }
            return;
        });
    }
    getPhantomJsDriver() {
        return __awaiter(this, void 0, void 0, function* () {
            // setup custom phantomJS capability https://github.com/SeleniumHQ/selenium/issues/2069
            const phantomjsExe = require('phantomjs-prebuilt').path;
            if (!phantomjsExe) {
                throw new Error('phantomjs binary path not found');
            }
            // const phantomjsExe = require('phantomjs2').path
            const phantomjsArgs = [
                '--load-images=false',
                '--ignore-ssl-errors=true',
                '--web-security=false',
                '--ssl-protocol=any',
            ];
            if (config_1.Config.debug) {
                phantomjsArgs.push('--remote-debugger-port=8080'); // XXX: be careful when in production env.
                phantomjsArgs.push('--webdriver-loglevel=DEBUG');
                // phantomjsArgs.push('--webdriver-logfile=webdriver.debug.log')
            }
            else {
                if (config_1.log && config_1.log.level() === 'silent') {
                    phantomjsArgs.push('--webdriver-loglevel=NONE');
                }
                else {
                    phantomjsArgs.push('--webdriver-loglevel=ERROR');
                }
            }
            const customPhantom = selenium_webdriver_1.Capabilities.phantomjs()
                .setAlertBehavior('ignore')
                .set('phantomjs.binary.path', phantomjsExe)
                .set('phantomjs.cli.args', phantomjsArgs);
            config_1.log.silly('PuppetWebBrowserDriver', 'phantomjs binary: ' + phantomjsExe);
            config_1.log.silly('PuppetWebBrowserDriver', 'phantomjs args: ' + phantomjsArgs.join(' '));
            const driver = new selenium_webdriver_1.Builder()
                .withCapabilities(customPhantom)
                .build();
            // const valid = await this.valid(driver)
            // if (!valid) {
            //   throw new Error('invalid driver founded')
            // }
            /* tslint:disable:jsdoc-format */
            /**
             *  FIXME: ISSUE #21 - https://github.com/zixia/wechaty/issues/21
             *
             *	http://phantomjs.org/api/webpage/handler/on-resource-requested.html
             *	http://stackoverflow.com/a/29544970/1123955
             *  https://github.com/geeeeeeeeek/electronic-wechat/pull/319
             *
             */
            //   	driver.executePhantomJS(`
            // this.onResourceRequested = function(request, net) {
            //    console.log('REQUEST ' + request.url);
            //    blockRe = /wx\.qq\.com\/\?t=v2\/fake/i
            //    if (blockRe.test(request.url)) {
            //        console.log('Abort ' + request.url);
            //        net.abort();
            //    }
            // }
            // `)
            // https://github.com/detro/ghostdriver/blob/f976007a431e634a3ca981eea743a2686ebed38e/src/session.js#L233
            // driver.manage().timeouts().pageLoadTimeout(2000)
            return driver;
        });
    }
    valid(driver) {
        return __awaiter(this, void 0, void 0, function* () {
            config_1.log.verbose('PuppetWebBrowserDriver', 'valid()');
            try {
                const session = yield new Promise((resolve, reject) => {
                    /**
                     * Be careful about this TIMEOUT, the total time(TIMEOUT x retry) should not trigger Watchdog Reset
                     * because we are in state(open, false) state, which will cause Watchdog Reset failure.
                     * https://travis-ci.org/wechaty/wechaty/jobs/179022657#L3246
                     */
                    const TIMEOUT = 7 * 1000;
                    let watchdogTimer;
                    watchdogTimer = setTimeout(() => {
                        const e = new Error('valid() driver.getSession() timeout(halt?)');
                        config_1.log.warn('PuppetWebBrowserDriver', e.message);
                        // record timeout by set timer to null
                        watchdogTimer = null;
                        config_1.log.verbose('PuppetWebBrowserDriver', 'watchdogTimer = %s after set null', watchdogTimer);
                        // 1. Promise rejected
                        reject(e);
                        return;
                    }, TIMEOUT);
                    config_1.log.verbose('PuppetWebBrowserDriver', 'valid() getSession()');
                    driver.getSession()
                        .then(driverSession => {
                        config_1.log.verbose('PuppetWebBrowserDriver', 'valid() getSession() then() done');
                        if (watchdogTimer) {
                            config_1.log.verbose('PuppetWebBrowserDriver', 'valid() getSession() then() watchdog timer exist, will be cleared');
                            clearTimeout(watchdogTimer);
                            watchdogTimer = null;
                            config_1.log.verbose('PuppetWebBrowserDriver', 'watchdogTimer = %s after set null', watchdogTimer);
                        }
                        else {
                            config_1.log.verbose('PuppetWebBrowserDriver', 'valid() getSession() then() watchdog timer not exist?');
                        }
                        // 2. Promise resolved
                        resolve(driverSession);
                        return;
                    })
                        .catch(e => {
                        config_1.log.warn('PuppetWebBrowserDriver', 'valid() getSession() catch() rejected: %s', e && e.message || e);
                        // do not call reject again if there's already a timeout
                        if (watchdogTimer) {
                            config_1.log.verbose('PuppetWebBrowserDriver', 'valid() getSession() catch() watchdog timer exist, will set it to null and call reject()');
                            // 3. Promise rejected
                            watchdogTimer = null;
                            reject(e);
                            return;
                        }
                        else {
                            config_1.log.verbose('PuppetWebBrowserDriver', 'valid() getSession() catch() watchdog timer not exist, will not call reject() again');
                        }
                    });
                });
                config_1.log.verbose('PuppetWebBrowserDriver', 'valid() driver.getSession() done()');
                if (!session) {
                    config_1.log.verbose('PuppetWebBrowserDriver', 'valid() found an invalid driver');
                    return false;
                }
            }
            catch (e) {
                config_1.log.warn('PuppetWebBrowserDriver', 'valid() driver.getSession() exception: %s', e.message);
                return false;
            }
            let two;
            try {
                two = yield driver.executeScript('return 1+1');
                config_1.log.verbose('PuppetWebBrowserDriver', 'valid() driver.executeScript() done');
            }
            catch (e) {
                two = e;
                config_1.log.warn('BrowserDriver', 'valid() fail: %s', e.message);
            }
            if (two !== 2) {
                config_1.log.warn('BrowserDriver', 'valid() fail: two = %s ?', two);
                return false;
            }
            config_1.log.silly('PuppetWebBrowserDriver', 'valid() driver ok');
            return true;
        });
    }
    close() { return this.driver.close(); }
    executeAsyncScript(script, ...args) { return this.driver.executeAsyncScript.apply(this.driver, arguments); }
    executeScript(script, ...args) { return this.driver.executeScript.apply(this.driver, arguments); }
    get(url) { return this.driver.get(url); }
    getSession() { return this.driver.getSession(); }
    manage() { return this.driver.manage(); }
    navigate() { return this.driver.navigate(); }
    quit() { return this.driver.quit(); }
}
exports.BrowserDriver = BrowserDriver;
exports.default = BrowserDriver;
//# sourceMappingURL=browser-driver.js.map